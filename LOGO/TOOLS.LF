
TO ; :COMMENTS
END

TO ABS :NUM
; [THE OUTPUT OF ABS IS]
; [ALWAYS POSITIVE]
OP IF :NUM < 0 [-:NUM] [:NUM]
END

TO ARCL :RADIUS :DEGREES
LOCAL "STEP LOCAL "REM
MAKE "STEP 2 * :RADIUS * 3.1416 / 36
MAKE "REM REMAINDER :DEGREES 10
REPEAT :DEGREES / 10 [LT 5 FD :STEP LT 5]
IF :REM > 0 [FD :STEP * :REM / 10 LT :REM]
END

TO ARCR :RADIUS :DEGREES
LOCAL "STEP LOCAL "REM
MAKE "STEP 2 * :RADIUS * 3.1416 / 36
MAKE "REM REMAINDER :DEGREES 10
REPEAT :DEGREES / 10 [RT 5 FD :STEP RT 5]
IF :REM > 0 [FD :STEP * :REM / 10 RT :REM]
END

TO CIRCLEL :RADIUS
LOCAL "STEP
MAKE "STEP 2 * :RADIUS * 3.1416 / 36
REPEAT 36 [LT 5 FD :STEP LT 5]
END

TO CIRCLER :RADIUS
LOCAL "STEP
MAKE "STEP 2 * :RADIUS * 3.1416 / 36
REPEAT 36 [RT 5 FD :STEP RT 5]
END

TO CONVERT :N :FRBASE :TOBASE
OP DEC.TO.ANYBASE ANYBASE.TO.DEC :N :FRBASE 1 :TOBASE
END

TO ANYBASE.TO.DEC :N :BASE :POWER
IF EMPTYP :N [OP 0]
OP ( :POWER * C.TO.N LAST :N ) + ANYBASE.TO.DEC BL :N :BASE :POWER * :BASE
END

TO DEC.TO.ANYBASE :N :BASE
IF :N < :BASE [OP N.TO.C :N]
OP WORD DEC.TO.ANYBASE INT QUOTIENT :N :BASE :BASE N.TO.C REMAINDER :N :BASE
END

TO C.TO.N :N
IF NUMBERP :N [OP :N]
OP (ASCII :N) - 55
END

TO N.TO.C :N
IF :N < 10 [OP :N]
OP CHAR 55 + :N
END

TO DECTOHEX :N
OP CONVERT :N 10 16
END

TO HEXTODEC :N
OP CONVERT :N 16 10
END

TO DIVISORP :A :B
OP 0 = REMAINDER :B :A
END

TO DRIVE
IF KEYP [LISTEN]
FD 1
DRIVE
END

TO LISTEN
MAKE "ANS RC
IF :ANS = "S [THROW "TOPLEVEL]
IF :ANS = "R [RT 10]
IF :ANS = "L [LT 10]
END

TO FOREVER :INSTRUCTIONLIST
RUN :INSTRUCTIONLIST
FOREVER :INSTRUCTIONLIST
END

TO LABELPIC :LABEL :POS
CT
LOCAL "CURSORPOS
MAKE "CURSORPOS CURSOR
SETCURSOR :POS
TYPE :LABEL
SETCURSOR :CURSORPOS
END

TO MAP :CMD :LIST
IF EMPTYP :LIST [STOP]
RUN LIST :CMD WORD "" FIRST :LIST
MAP :CMD BF :LIST
END

TO PEL :POS
OUTPUT ITEM (BYTEPOS (ROUND FIRST :POS)) 4PELS :POS
END

TO BYTEPOS :XPEL
IF :XPEL > 0 [OUTPUT 1 + REMAINDER (:XPEL - 1) 4] [OUTPUT 4 + REMAINDER :XPEL 4]
END

TO 4PELS :POS
LOCAL "P
LOCAL "N
MAKE "P []
MAKE "N DISPBYTE :POS
REPEAT 4 [MAKE "P FPUT REMAINDER :N 4 :P MAKE "N INT QUOTIENT :N 4]
OUTPUT :P
END

TO DISPBYTE :POS
OUTPUT .EXAMINE -18432 OFFSET :POS
END

TO OFFSET :POS
LOCAL "SCAN
MAKE "SCAN 100 - ROUND ((LAST :POS) * .SCRUNCH)
IF OR OR FIRST :POS > 160 FIRST :POS < -159 OR :SCAN > 199 :SCAN < 0 [PR [PLEASE ENTER A POSITION WHICH IS] PR [WITHIN THE VISIBLE LIMITS OF THE] PR [GRAPHICS SCREEN.] THROW "TOPLEVEL]
OUTPUT (8192 * REMAINDER :SCAN 2) + (80 * INT QUOTIENT :SCAN 2) + (INT QUOTIENT (159 + ROUND (FIRST :POS)) 4)
END

TO GREEN
SETPAL 0
OP 1
END

TO RED
SETPAL 0
OP 2
END

TO BROWN
SETPAL 0
OP 3
END

TO CYAN
SETPAL 1
OP 1
END

TO MAGENTA
SETPAL 1
OP 2
END

TO WHITE
SETPAL 1
OP 3
END

TO POLY :SIDE :ANGLE
FD :SIDE
RT :ANGLE
POLY :SIDE :ANGLE
END

TO PROMPT :MESSAGE
TYPE :MESSAGE
TYPE CHAR 32
END

TO SHOWARGS :ARGLIST
IF EMPTYP :ARGLIST [STOP]
MAKE "NEWDEF LPUT (LIST "PRINT "SENTENCE (LIST (FIRST :ARGLIST) "IS) (WORD ": FIRST :ARGLIST)) :NEWDEF
SHOWARGS BF :ARGLIST
END

TO SHOWLINES :INSTRUCTIONS
IF EMPTYP :INSTRUCTIONS [STOP]
MAKE "NEWDEF LPUT (LIST "TYPE FIRST :INSTRUCTIONS) :NEWDEF
MAKE "NEWDEF LPUT [STEPPER] :NEWDEF
MAKE "NEWDEF LPUT FIRST :INSTRUCTIONS :NEWDEF
SHOWLINES BF :INSTRUCTIONS
END

TO STEPPER
TYPE "??
IGNORE READLIST
END

TO IGNORE :INPUT
END

TO UNSTEP :PROC
IF EMPTYP :PROC [STOP]
IF LISTP :PROC [UNSTEP FIRST :PROC UNSTEP BF :PROC STOP]
IF EMPTYP TEXT WORD ". :PROC [PR SE :PROC [NOT STEPPED.] STOP]
COPYDEF :PROC WORD ". :PROC
ERASE WORD ". :PROC
END

TO STEP :PROC
IF EMPTYP :PROC [STOP]
IF LISTP :PROC [STEP FIRST :PROC STEP BF :PROC STOP]
IF PRIMITIVEP :PROC [PR SE [CAN'T STEP PRIMITIVE] :PROC STOP]
IF EMPTYP TEXT :PROC [PR SE [NO PROCEDURE NAMED] :PROC STOP]
COPYDEF WORD ". :PROC :PROC
MAKE "OLDDEF TEXT :PROC
MAKE "NEWDEF (LIST FIRST :OLDDEF)
MAKE "NEWDEF LPUT (LIST "PRINT (LIST "ENTERING :PROC)) :NEWDEF
SHOWARGS FIRST :OLDDEF
SHOWLINES BF :OLDDEF
DEFINE :PROC :NEWDEF
END

TO TEACH
LOCAL "THISLINE
DEFINE "PROGRAM [[]]
CLEARSCREEN PENDOWN
ADDLINES
IF NOT EMPTYP BUTFIRST TEXT "PROGRAM [NAMEIT]
END

TO ADDLINES
TYPE [\>?]
MAKE "THISLINE READLIST
IF :THISLINE = [END] [STOP]
ADDIT :THISLINE
ADDLINES
END

TO ADDIT :THISLINE
IF EMPTYP :THISLINE [STOP]
TEST :THISLINE = [ERASE]
IFTRUE [WIPEOUT]
IFFALSE [RUNSTORE]
END

TO WIPEOUT
DEFINE "PROGRAM BUTLAST TEXT "PROGRAM
CLEARSCREEN
RUN [PROGRAM]
END

TO RUNSTORE
CATCH "ERROR [RUN :THISLINE]
LOCAL "GOOF
MAKE "GOOF ERROR
TEST EMPTYP :GOOF
IFTRUE [DEFINE "PROGRAM LPUT :THISLINE TEXT "PROGRAM]
IFFALSE [PRINT FIRST BUTFIRST :GOOF]
END

TO NAMEIT
LOCAL "NAME
PRINT [What should I call this?]
MAKE "NAME READLIST
TEST EMPTYP :NAME
IFTRUE [ERASE "PROGRAM STOP]
TEST DEFINEDP FIRST :NAME
IFTRUE [TRYAGAIN]
IFFALSE [COPY]
END

TO TRYAGAIN
PRINT SENTENCE FIRST :NAME [is already defined]
PRINT []
NAMEIT
END

TO COPY
COPYDEF FIRST :NAME "PROGRAM
PRINT SENTENCE FIRST :NAME [defined]
ERASE "PROGRAM
END

TO PROGRAM
END

TO BLACK.BLUE
OP [0 1]
END

TO BLACK.GREEN
OP [0 2]
END

TO BLACK.CYAN
OP [0 3]
END

TO BLACK.RED
OP [0 4]
END

TO BLACK.MAGENTA
OP [0 5]
END

TO BLACK.BROWN
OP [0 6]
END

TO BLACK.WHITE
OP [0 7]
END

TO WRITEWORD :WD
IF EMPTYP :WD [FD 5 STOP]
SETSHAPE ASCII FIRST :WD
STAMP FD 12
WRITEWORD BF :WD
END

TO TITLE :XC :YC :LST
MAKE "NUM 1
PU SETPOS SE :XC :YC
RT 90 ST
REPEAT COUNT :LST [WRITEWORD ITEM :NUM :LST MAKE "NUM :NUM + 1]
SETSHAPE "TURTLE
HT PD SETH 0
END

TO WHICH :MEMBER :LIST
IF NOT MEMBERP :MEMBER :LIST [OP 0]
IF :MEMBER = FIRST :LIST [OUTPUT 1]
OUTPUT 1 + WHICH :MEMBER BF :LIST
END

TO WHILE :CONDITION :INSTRUCTIONLIST
TEST RUN :CONDITION
IFFALSE [STOP]
RUN :INSTRUCTIONLIST
WHILE :CONDITION :INSTRUCTIONLIST
END

